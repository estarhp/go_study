package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
)

type AutoGenerated struct {
	Success bool   `json:"success"`
	Code    string `json:"code"`
	Message string `json:"message"`
	Data    struct {
		FileID    int    `json:"file_id"`
		Width     int    `json:"width"`
		Height    int    `json:"height"`
		Filename  string `json:"filename"`
		Storename string `json:"storename"`
		Size      int    `json:"size"`
		Path      string `json:"path"`
		Hash      string `json:"hash"`
		URL       string `json:"url"`
		Delete    string `json:"delete"`
		Page      string `json:"page"`
	} `json:"data"`
	RequestID string `json:"RequestId"`
}

func main() {
	image, err := os.Open("v2-1c15aad66d7889fe522661a90f623dc4_1440w.jpg")
	if err != nil {
		println(err)
		return
	}
	defer func(image *os.File) {
		err := image.Close()
		if err != nil {
			println(err)
		}
	}(image)
	//设置参数

	var body = new(bytes.Buffer)
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile("smfile", "v2-1c15aad66d7889fe522661a90f623dc4_1440w.jpg")

	if err != nil {
		fmt.Println("创建表单数据失败：", err)
		return
	}

	_, err = io.Copy(part, image)

	if err != nil {
		fmt.Println("添加文件内容失败：", err)
		return
	}

	err = writer.Close()

	if err != nil {
		fmt.Println("关闭表单数据失败：", err)
		return
	}

	//values := url.Values{}
	//values.Set("format", "json")
	//values.Set("smfile", body)
	// 发起 GET 请求
	req, err := http.NewRequest("POST", "https://sm.ms/api/v2/upload", body)
	if err != nil {
		fmt.Println("请求失败：", err)
		return
	}

	req.Header.Set("Authorization", "YUXTOHcLUFW7QSyzVRqpYYuXAw8iShY1")
	req.Header.Set("Content-Type", writer.FormDataContentType())
	client := &http.Client{
		Transport: &http.Transport{
			Proxy: func(req *http.Request) (*url.URL, error) {
				// 设置代理服务器地址和端口号
				proxyUrl, err := url.Parse("http://127.0.0.1:1080")
				if err != nil {
					return nil, err
				}
				return proxyUrl, nil
			},
		},
	}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("请求失败：", err)
		return
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {

		}
	}(resp.Body)

	fmt.Println(resp.Status)

	respbody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("读取响应内容失败：", err)
		return
	}
	fmt.Println(string(respbody))
	var p AutoGenerated
	err = json.Unmarshal(respbody, &p)
	if err != nil {
		return
	}

	fmt.Println(p.Data.URL)
}
